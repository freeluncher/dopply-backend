# Service     @staticmethod
    def classify_fetal_heart_rate(fhr_data: List[int], gestational_age: int, maternal_age: int = 28, duration_minutes: int = None) -> Dict[str, Any]:
        """
        Classify fetal heart rate data dari ESP32
        
        Args:
            fhr_data: List of BPM values dari ESP32
            gestational_age: Gestational age in weeks
            maternal_age: Maternal age (optional)
            duration_minutes: Duration of monitoring (optional)
            
        Returns:
            Dict containing classification results
        """
        if not fhr_data:
            raise ValueError("FHR data cannot be empty")
            
        if not 1 <= gestational_age <= 42:
            raise ValueError("Gestational age must be between 1 and 42 weeks")
            
        # Filter out invalid readings (BPM = 0 dari ESP32)
        valid_readings = [bpm for bpm in fhr_data if bpm > 0]
        
        if not valid_readings:
            raise ValueError("No valid BPM readings found")
            
        # Calculate statistics
        avg_bpm = statistics.mean(valid_readings)ng Classification dan Business Logic
from typing import List, Dict, Any, Optional
from datetime import datetime
import statistics
import json
from app.models.medical import FetalClassification, RiskLevel, OverallClassification

class FetalMonitoringService:
    """Service untuk classification dan business logic fetal monitoring"""
    
    @staticmethod
    def classify_fetal_bpm(bpm_readings: List[int], gestational_age: int) -> Dict[str, Any]:
        """
        Classify fetal BPM berdasarkan gestational age dan patterns
        
        Args:
            bmp_readings: List of BMP values
            gestational_age: Gestational age in weeks
            
        Returns:
            Dict containing classification results
        """
        if not bpm_readings:
            raise ValueError("BPM readings cannot be empty")
            
        if not 1 <= gestational_age <= 42:
            raise ValueError("Gestational age must be between 1 and 42 weeks")
            
        # Calculate statistics
        avg_bpm = statistics.mean(bpm_readings)
        
        # Define normal ranges by gestational age
        normal_range = FetalMonitoringService._get_normal_range(gestational_age)
        
        # Primary classification based on average BPM
        primary_classification = FetalMonitoringService._classify_by_average(avg_bpm, normal_range)
        
        # Check for irregularity
        variability = FetalMonitoringService._calculate_variability(bpm_readings)
        is_irregular = FetalMonitoringService._is_irregular_pattern(bpm_readings, variability)
        
        # Determine overall classification
        if is_irregular:
            overall_classification = OverallClassification.IRREGULAR
            risk_level = RiskLevel.MEDIUM
        else:
            overall_classification = primary_classification
            risk_level = FetalMonitoringService._determine_risk_level(primary_classification, variability)
        
        # Generate recommendations
        recommendations = FetalMonitoringService._generate_recommendations(
            overall_classification, avg_bpm, variability, gestational_age
        )
        
        return {
            "primary_classification": primary_classification.value,
            "overall_classification": overall_classification.value,
            "risk_level": risk_level.value,
            "average_bpm": round(avg_bpm, 2),
            "variability": round(variability, 2),
            "recommendations": recommendations,
            "gestational_age": gestational_age,
            "total_readings": len(bpm_readings),
            "min_bpm": min(bpm_readings),
            "max_bpm": max(bpm_readings),
            "is_irregular": is_irregular,
            "normal_range": normal_range
        }
    
    @staticmethod
    def _get_normal_range(gestational_age: int) -> Dict[str, int]:
        """Get normal BPM range berdasarkan gestational age"""
        if gestational_age < 20:
            return {"min": 120, "max": 160}
        elif gestational_age < 32:
            return {"min": 110, "max": 160}
        else:
            return {"min": 110, "max": 160}
    
    @staticmethod
    def _classify_by_average(avg_bpm: float, normal_range: Dict[str, int]) -> FetalClassification:
        """Classify berdasarkan average BPM"""
        if avg_bpm < normal_range["min"]:
            return FetalClassification.BRADYCARDIA
        elif avg_bpm > normal_range["max"]:
            return FetalClassification.TACHYCARDIA
        else:
            return FetalClassification.NORMAL
    
    @staticmethod
    def _calculate_variability(bmp_readings: List[int]) -> float:
        """Calculate BPM variability (standard deviation)"""
        if len(bmp_readings) < 2:
            return 0.0
        return statistics.stdev(bmp_readings)
    
    @staticmethod
    def _is_irregular_pattern(bmp_readings: List[int], variability: float) -> bool:
        """Determine if the pattern is irregular"""
        # High variability indicates irregular pattern
        if variability > 25:
            return True
        
        # Check for abrupt changes
        if len(bmp_readings) < 2:
            return False
            
        abrupt_changes = 0
        for i in range(1, len(bmp_readings)):
            change = abs(bmp_readings[i] - bmp_readings[i-1])
            if change > 25:  # Abrupt change threshold
                abrupt_changes += 1
        
        # If more than 20% of readings have abrupt changes
        return (abrupt_changes / len(bmp_readings)) > 0.2
    
    @staticmethod
    def _determine_risk_level(classification: FetalClassification, variability: float) -> RiskLevel:
        """Determine risk level berdasarkan classification dan variability"""
        if classification == FetalClassification.NORMAL:
            if variability < 5:
                return RiskLevel.MEDIUM  # Too little variability
            elif variability > 15:
                return RiskLevel.MEDIUM  # Too much variability
            else:
                return RiskLevel.LOW
        elif classification in [FetalClassification.BRADYCARDIA, FetalClassification.TACHYCARDIA]:
            return RiskLevel.HIGH
        else:
            return RiskLevel.MEDIUM
    
    @staticmethod
    def _generate_recommendations(classification: OverallClassification, avg_bpm: float, 
                                variability: float, gestational_age: int) -> List[str]:
        """Generate recommendations berdasarkan hasil classification"""
        recommendations = []
        
        if classification == OverallClassification.NORMAL:
            recommendations.append("Fetal heart rate normal - monitor rutin")
            if variability < 5:
                recommendations.append("Variabilitas rendah - pertimbangkan monitoring lebih sering")
        
        elif classification == OverallClassification.BRADYCARDIA:
            recommendations.append("Bradycardia terdeteksi - konsultasi dengan dokter segera")
            recommendations.append("Monitor posisi ibu dan aliran oksigen")
            
        elif classification == OverallClassification.TACHYCARDIA:
            recommendations.append("Tachycardia terdeteksi - evaluasi kondisi ibu dan janin")
            recommendations.append("Periksa demam, dehidrasi, atau stress maternal")
            
        elif classification == OverallClassification.IRREGULAR:
            recommendations.append("Pola denyut tidak teratur - monitoring ketat diperlukan")
            recommendations.append("Evaluasi aktivitas janin dan kontraksi uterus")
        
        # Gestational age specific recommendations
        if gestational_age < 28:
            recommendations.append("Usia gestasi < 28 minggu - monitoring khusus diperlukan")
        elif gestational_age > 37:
            recommendations.append("Usia gestasi > 37 minggu - siapkan rencana persalinan")
        
        return recommendations

    # =====================================
    # SIMPLIFIED MONITORING SESSION METHODS
    # =====================================
    
    @staticmethod
    def save_monitoring_session(db, request, user_id: int) -> Dict[str, Any]:
        """Save a fetal monitoring session using simplified records table"""
        from app.models.medical import Record, Patient
        from app.core.time_utils import get_local_now
        
        # Get patient info
        patient = db.query(Patient).filter(Patient.id == request.patient_id).first()
        if not patient:
            raise ValueError("Patient not found")
        
        # Extract BPM data from readings
        bpm_data = [reading.bpm for reading in request.readings] if request.readings else []
        
        # Classify the BPM data if available
        classification = "unclassified"
        if bpm_data and len(bpm_data) > 0:
            try:
                classification_result = FetalMonitoringService.classify_fetal_bpm(bpm_data, request.gestational_age)
                classification = classification_result.get('overall_classification', 'unclassified')
            except Exception:
                classification = "unclassified"
        
        # Create monitoring record
        record = Record(
            patient_id=request.patient_id,
            start_time=request.start_time,
            end_time=request.end_time or get_local_now(),
            monitoring_duration=(request.end_time - request.start_time).total_seconds() / 60 if request.end_time else 0,
            heart_rate_data=json.dumps(bpm_data) if bpm_data else "[]",
            classification=classification,
            notes=request.notes or "",
            doctor_notes=getattr(request, 'doctor_notes', ""),
            gestational_age=request.gestational_age,
            created_by=user_id
        )
        
        db.add(record)
        db.commit()
        db.refresh(record)
        
        return {
            "id": str(record.id),
            "patient_id": record.patient_id,
            "doctor_id": user_id,
            "monitoring_type": request.monitoring_type.value if hasattr(request.monitoring_type, 'value') else str(request.monitoring_type),
            "gestational_age": record.gestational_age,
            "start_time": record.start_time,
            "end_time": record.end_time,
            "notes": record.notes,
            "doctor_notes": record.doctor_notes,
            "shared_with_doctor": getattr(request, 'shared_with_doctor', False),
            "classification": record.classification,
            "readings": [],  # Empty for simplified system
            "result": None,  # Empty for simplified system
            "created_at": record.start_time,
            "updated_at": record.start_time
        }

    @staticmethod
    def get_monitoring_sessions(db, patient_id: Optional[int] = None, skip: int = 0, limit: int = 20) -> Dict[str, Any]:
        """Get fetal monitoring sessions from records table"""
        from app.models.medical import Record
        
        query = db.query(Record)
        if patient_id:
            query = query.filter(Record.patient_id == patient_id)
        
        total_count = query.count()
        records = query.order_by(Record.start_time.desc()).offset(skip).limit(limit).all()
        
        session_list = []
        for record in records:
            session_list.append({
                "id": str(record.id),
                "patient_id": record.patient_id,
                "doctor_id": record.created_by,
                "monitoring_type": "clinic",  # Default type for simplified system
                "gestational_age": record.gestational_age or 0,
                "start_time": record.start_time,
                "end_time": record.end_time,
                "notes": record.notes or "",
                "doctor_notes": record.doctor_notes or "",
                "shared_with_doctor": False,  # Default for simplified system
                "classification": record.classification,
                "readings": [],  # Empty for simplified system
                "result": None,  # Empty for simplified system
                "created_at": record.start_time,
                "updated_at": record.start_time
            })
        
        return {
            "sessions": session_list,
            "total_count": total_count,
            "current_page": (skip // limit) + 1 if limit > 0 else 1,
            "total_pages": (total_count + limit - 1) // limit if limit > 0 else 1
        }

    @staticmethod
    def get_monitoring_session(db, session_id: int, user_id: int, user_role: str) -> Optional[Dict[str, Any]]:
        """Get a specific monitoring session from records table"""
        from app.models.medical import Record, Patient
        
        record = db.query(Record).filter(Record.id == session_id).first()
        if not record:
            return None
        
        # Check access permissions
        if user_role == "patient":
            patient = db.query(Patient).filter(Patient.patient_id == user_id).first()
            if not patient or record.patient_id != patient.id:
                return None
        
        return {
            "id": str(record.id),
            "patient_id": record.patient_id,
            "doctor_id": record.created_by,
            "monitoring_type": "manual",
            "gestational_age": record.gestational_age or 0,
            "start_time": record.start_time,
            "end_time": record.end_time,
            "notes": record.notes or "",
            "doctor_notes": record.doctor_notes or "",
            "classification": record.classification,
            "heart_rate_data": json.loads(record.heart_rate_data) if record.heart_rate_data else [],
            "created_at": record.start_time
        }

    @staticmethod
    def share_session_with_doctor(db, session_id: int, patient_id: int, doctor_id: int) -> Dict[str, Any]:
        """Share a monitoring session with a doctor by creating a copy or notification"""
        from app.models.medical import Record, User, Patient
        
        # Validate session ownership
        record = db.query(Record).filter(
            Record.id == session_id,
            Record.patient_id == patient_id
        ).first()
        
        if not record:
            raise ValueError("Session not found or access denied")
        
        # Validate doctor exists
        doctor = db.query(User).filter(User.id == doctor_id).first()
        if not doctor or doctor.role.value != "doctor":
            raise ValueError("Doctor not found")
        
        # For simplified system, we just update the doctor_notes to indicate sharing
        sharing_note = f"Shared with Dr. {doctor.name} on {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        existing_notes = record.doctor_notes or ""
        
        if sharing_note not in existing_notes:
            record.doctor_notes = f"{existing_notes}\n{sharing_note}".strip()
            db.commit()
        
        return {
            "message": f"Session shared with Dr. {doctor.name}",
            "session_id": str(record.id),
            "doctor_id": doctor_id,
            "doctor_name": doctor.name,
            "shared_at": datetime.now()
        }

    # =====================================
    # PREGNANCY INFO METHODS 
    # =====================================
    
    @staticmethod
    def create_pregnancy_info(db, patient_id: int, pregnancy_data) -> Dict[str, Any]:
        """Create pregnancy information"""
        from app.models.medical import PregnancyInfo
        
        # Check if pregnancy info already exists
        existing = db.query(PregnancyInfo).filter(PregnancyInfo.patient_id == patient_id).first()
        if existing:
            raise ValueError("Pregnancy information already exists for this patient")
        
        pregnancy_info = PregnancyInfo(
            patient_id=patient_id,
            last_menstrual_period=pregnancy_data.last_menstrual_period,
            estimated_due_date=pregnancy_data.estimated_due_date,
            gestational_age_weeks=pregnancy_data.gestational_age_weeks,
            gestational_age_days=pregnancy_data.gestational_age_days,
            risk_factors=pregnancy_data.risk_factors,
            notes=pregnancy_data.notes
        )
        
        db.add(pregnancy_info)
        db.commit()
        db.refresh(pregnancy_info)
        
        return {
            "id": pregnancy_info.id,
            "patient_id": pregnancy_info.patient_id,
            "last_menstrual_period": pregnancy_info.last_menstrual_period,
            "estimated_due_date": pregnancy_info.estimated_due_date,
            "gestational_age_weeks": pregnancy_info.gestational_age_weeks,
            "gestational_age_days": pregnancy_info.gestational_age_days,
            "risk_factors": pregnancy_info.risk_factors,
            "notes": pregnancy_info.notes,
            "created_at": pregnancy_info.created_at,
            "updated_at": pregnancy_info.updated_at
        }
    
    @staticmethod
    def get_pregnancy_info(db, patient_id: int) -> Optional[Dict[str, Any]]:
        """Get pregnancy information"""
        from app.models.medical import PregnancyInfo
        
        pregnancy_info = db.query(PregnancyInfo).filter(PregnancyInfo.patient_id == patient_id).first()
        if not pregnancy_info:
            return None
        
        return {
            "id": pregnancy_info.id,
            "patient_id": pregnancy_info.patient_id,
            "last_menstrual_period": pregnancy_info.last_menstrual_period,
            "estimated_due_date": pregnancy_info.estimated_due_date,
            "gestational_age_weeks": pregnancy_info.gestational_age_weeks,
            "gestational_age_days": pregnancy_info.gestational_age_days,
            "risk_factors": pregnancy_info.risk_factors,
            "notes": pregnancy_info.notes,
            "created_at": pregnancy_info.created_at,
            "updated_at": pregnancy_info.updated_at
        }
    
    @staticmethod
    def update_pregnancy_info(db, patient_id: int, pregnancy_data) -> Optional[Dict[str, Any]]:
        """Update pregnancy information"""
        from app.models.medical import PregnancyInfo
        
        pregnancy_info = db.query(PregnancyInfo).filter(PregnancyInfo.patient_id == patient_id).first()
        if not pregnancy_info:
            return None
        
        pregnancy_info.last_menstrual_period = pregnancy_data.last_menstrual_period
        pregnancy_info.estimated_due_date = pregnancy_data.estimated_due_date
        pregnancy_info.gestational_age_weeks = pregnancy_data.gestational_age_weeks
        pregnancy_info.gestational_age_days = pregnancy_data.gestational_age_days
        pregnancy_info.risk_factors = pregnancy_data.risk_factors
        pregnancy_info.notes = pregnancy_data.notes
        
        db.commit()
        db.refresh(pregnancy_info)
        
        return {
            "id": pregnancy_info.id,
            "patient_id": pregnancy_info.patient_id,
            "last_menstrual_period": pregnancy_info.last_menstrual_period,
            "estimated_due_date": pregnancy_info.estimated_due_date,
            "gestational_age_weeks": pregnancy_info.gestational_age_weeks,
            "gestational_age_days": pregnancy_info.gestational_age_days,
            "risk_factors": pregnancy_info.risk_factors,
            "notes": pregnancy_info.notes,
            "created_at": pregnancy_info.created_at,
            "updated_at": pregnancy_info.updated_at
        }
